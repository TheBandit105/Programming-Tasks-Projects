package babycino;

import java.util.ArrayList;

// A block of Three Address Code.
public class TACBlock extends ArrayList<TACOp> {
    // The register that holds the "result" of the block after execution.
    // If null, assume r1 in the last TACOp holds the result.
    String result;
    
    public TACBlock() {
        this.result = null;
    }

    // Set the result register for the block.
    public void setResult(String r) {
        this.result = r;
    }

    // Get the result register for the block.
    public String getResult() {
        if (this.result != null) {
            return this.result;
        }
        // Default to r1 in the last TACOp.
        return this.get(this.size()-1).getR1();
    }

    // Dump the instructions to standard output, primarily for debugging.
    public void dump() {
        for (TACOp op : this) {
            System.out.println(op.toString());
        }
    }

    // Get the highest-valued r-register used in the block.
    public int getMaxR() {
        return getMaxReg("r");
    }

    // Get the highest-valued vl-register used in the block.
    public int getMaxVL() {
        return getMaxReg("vl");
    }

    // Get the highest-valued vg-register used in the block.
    public int getMaxVG() {
        return getMaxReg("vg");
    }

    // Helper functions for the above:

    private int getMaxReg(String prefix) {
        int max = -1;
        for (TACOp op : this) {
            max = Math.max(max, regPrefixToInt(prefix, op.getR1()));
            max = Math.max(max, regPrefixToInt(prefix, op.getR2()));
            max = Math.max(max, regPrefixToInt(prefix, op.getR3()));
        }
        return max;
    }

    private static int regPrefixToInt(String prefix, String r) {
        if (r == null || !r.startsWith(prefix)) {
            return -1;
        }
        return Integer.parseInt(r.substring(prefix.length()));
    }

    // Count the number of uses of param in a block.
    // For the code generated by the compiler, this places an upper bound on
    // the number of parameters that might be passed to a method.
    // When compiling to C code as a target, this becomes the size of the
    // global array used to pass parameters.
    // (OK, param could conceivably be used in a loop arbitrarily many times
    // by intermediate code, but computing an upper bound on that is
    // undecidable. A safe alternative would be to allocate the array
    // dynamically, checking on each param push, but that would make the
    // generated C code less obviously translatable to assembly language.)
    public int countParam() {
        int count = 0;
        for (TACOp op : this) {
            if (op.getType() == TACOpType.PARAM) {
                count++;
            }
        }
        return count;
    }

}

